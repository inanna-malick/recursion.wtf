+++
title = "Recursion: a quick introduction"
date = "2023-10-16"
author = "Inanna Malick"
authorTwitter = "inanna_malick"
tags = ["recursion", "rust", "code"]
keywords = ["recursion", "rust", "code"]
showFullContent = false
+++

The [recursion crate](https://crates.io/crates/recursion) provides abstractions for separating the _machinery_ of recursion from the _logic_ of recursion. This is similar to how iterators separate the _machinery_ of iteration from the _logic_ of iteration, allowing us to replace  {{< highlight c "hl_inline=true">}} for (int i = 0; i < 10; ++i) {} {{< /highlight >}} with {{< highlight rust "hl_inline=true">}}  for item in items.iter() {}{{< /highlight >}} 

This post doesn't attempt to explain every feature of the recursion crate (that's what the [cargo docs](https://docs.rs/recursion/0.5.1/recursion/) are for), but instead aims to spark your curiosity and to show off the tools provided by the recursion crate.



<!--more--> 

## Recursive types

We'll start with a simple expression language made up of binary operators and true/false boolean values. 


```rust
enum Expr {
    And(Box<Expr>, Box<Expr>),
    Or(Box<Expr>, Box<Expr>),
    Not(Box<Expr>),
    Literal(bool),
}
```

For working with this `Expr` type we'll define a _frame_ type `ExprFrame<A>`. It's exactly the same as `Expr`, except the recursive self-reference `Box<Self>` is replaced with `A`. This may be a bit confusing at first, but this idiom unlocks a lot of potential (expressiveness, stack safety, etc). You can think of `ExprFrame<A>` as representing a single _stack frame_ in a recursive algorithm.


```rust
enum ExprFrame<A> {
    And(A, A),
    Or(A, A),
    Not(A),
    Literal(bool),
}
```

Now we define the relationship between `Expr` and `ExprFrame`. This requires us to implement two traits: `MappableFrame` and `Collapsible`. The actual implementation of these traits is fairly mechanical, but if you're interested they can be seen in this collapsed code block:

{{< details "CLICK TO EXPAND" >}}

```rust
impl MappableFrame for ExprFrame<PartiallyApplied> {
    type Frame<X> = ExprFrame<X>;
    
    fn map_frame<A, B>(input: Self::Frame<A>, mut f: impl FnMut(A) -> B) -> Self::Frame<B> {
        match input {
            ExprFrame::And(a, b) => ExprFrame::And(f(a), f(b)),
            ExprFrame::Or(a, b) => ExprFrame::Or(f(a), f(b)),
            ExprFrame::Not(a) => ExprFrame::Not(f(a)),
            ExprFrame::Literal(x) => ExprFrame::Literal(x),
        }
    }
}

impl<'a> Collapsible for &'a Expr {
    type FrameToken = ExprFrame<PartiallyApplied>;
    
    fn into_frame(self) -> <Self::FrameToken as MappableFrame>::Frame<Self> {
        match self {
            Expr::And(a, b) => ExprFrame::And(a, b),
            Expr::Or(a, b) => ExprFrame::Or(a, b),
            Expr::Not(a) => ExprFrame::Not(a),
            Expr::Literal(x) => ExprFrame::Literal(*x),
        }
    }
}
```

{{< /details >}}


Generally speaking, you won't use these traits yourself - they're used by the internals of the recursion crate. The recursion crate docs contain full explanations of these traits, and how to implement them.

# Writing Recursive Algorithms

The `Collapsible` trait provides the ability to write recursive algorithms that _collapse_ some structure into a single value, frame by frame. Let's look at some examples:

### Evaluating expressions

Here's what evaluating an expression with `collapse_frames` looks like:

```rust
fn eval(e: &Expr) -> bool {  
    e.collapse_frames(|frame| match frame {
        ExprFrame::And(a, b) => a && b,
        ExprFrame::Or(a, b) => a || b,
        ExprFrame::Not(a) => !a,
        ExprFrame::Literal(x) => x,
    })
}
```

Note that the function passed to `collapse_frames` only collapses a single frame of type `ExprFrame<bool>` - `collapse_frames` handles the rest.

Here's a GIF showing each stage of the evaluation of `false && true || true` using this function

{{< figure src="/img/recursion_crate/eval_simple.gif" alt="visualization showing evaluation of simple boolean expression" position="center" style="border-radius: 8px;" >}}

This GIF was generated by a special _instrumented_ version of the recursive machinery used by `collapse_frames`  that automatically generates animated 'stack traces'u.

### Introducing some complexity: predicates

An expression language that only supports boolean literals is of limited use. A real-world expression language might contain a series of predicates representing queries against the state of the world. Let's add a simple Lookup predicate that just uses some key to fetch a boolean value from a provided hashmap of key-value mappings.

```rust
enum Expr {
    And(Box<Expr>, Box<Expr>),
    Or(Box<Expr>, Box<Expr>),
    Not(Box<Expr>),
    Literal(bool),
    LookupKey(usize),
}

enum ExprFrame<A> {
    And(A, A),
    Or(A, A),
    Not(A),
    Literal(bool),
    LookupKey(usize),
}
```

Now we have something a bit more useful - an expression language with predicates can be a powerful tool for defining queries, filtering rules, and similar things. The recursion crate is used for exactly this in nextest's test-filtering DSL, as implemented in [nextest-filtering](https://github.com/nextest-rs/nextest/tree/main/nextest-filtering).

## Fallible functions

Because this Expr type is more suited to interacting with the world, it can fail. A lookup operation might reference a key that doesn't exist, in which case the expression might fail to evaluate. The recursion crate provides a `try_collapse_frames` function for precisely this case:

```rust
fn try_eval(e: &Expr, lookup_table: HashMap<usize, bool>) -> Result<bool, String> {
    e.try_collapse_frames(|frame| match frame {
        ExprFrame::And(a, b) => Ok(a && b),
        ExprFrame::Or(a, b) => Ok(a || b),
        ExprFrame::Not(a) => Ok(!a),
        ExprFrame::Literal(x) => Ok(x),
        ExprFrame::LookupKey(key) => match lookup_table.get(&key) {
            Some(x) => Ok(*x),
            None => Err(format!("lookup for {:?} failed", key)),
        },
    })
}
```


Here you can see visualizations of this function running (example expr from rs file) on two lookup tables - first, one that has mappings for all the relevant keys:

// GIFs

Next, the same expression is run against a lookup table missing a key. Note how evaluation terminates immediately when lookup fails.

// GIFs


## Next time

In my next post, I'll show how this can be expanded into a more fully worked example: `detect`, a tool for finding files on the filesystem using an expression language matcher. It supports multiple predicates, and runs evaluation in multiple stages to minimize syscall use. I'm not going to spoil everything, but here's a visualization showing it short circuit to avoid more expensive operations if an expression can be evaluated by just looking at the filename:

{{< figure src="/img/recursion_crate/eval_detect_teaser.gif" alt="visualization showing evaluation of a more complex boolean expression" position="center" style="border-radius: 8px;" >}}
